\section{Over deze module}

De aanpak van het thema \textit{functioneel programmeren} is wat anders dan gebruikelijk, met als bedoeling de essentiële begrippen op een logische en geleidelijke manier in te voeren.

Eén van de uitgangspunten is ``gebruik voor definitie'': voor het gebruik heb je voldoende aan een specificatie, die soms wat informeel kan zijn. Bij de implementatie komen dan alle formele details aan bod, maar op dat moment is de noodzaak van die details vaak wel duidelijk.

Functioneel programmeren gaat voor een belangrijk deel over \textit{abstractie}. Maar het is belangrijk om zo concreet mogelijk te beginnen, en de abstractie daarna in te voeren als een volgende, logische stap.

\textbf{Functies.} Het eerste onderdeel betreft het functiebegrip: een functie als \textit{uitgestelde berekening}. Er zijn twee redenen om die berekening uit te stellen:

\begin{itemize}
\item (a) je kent de invoer (argumenten) van de functie nog niet;
\item (b) je hebt het resultaat van de functie nog niet nodig.
\end{itemize}

Ad (a): als je een functie toepast op één of meerdere argument-waarden, kun je de berekening van de functie (uit de functie-definitie) uitvoeren.

Ad (b): je hoeft de functie niet uit te voeren, ook als de invoer (argumenten) wel beschikbaar zijn in een functie-toepassing; dit kun je uitstellen totdat het resultaat van deze functie-toepassing nodig is. Dit \textit{lazy evaluation} principe wordt in sommige functionele programmeertalen, zoals ook Haskell, gebruikt. In onze voorbeelden zullen we echter vrijwel altijd een \textit{stricte} evaluatie gebruiken: we rekenen een functie-toepassing uit zodra de argumenten beschikbaar zijn.

Het belangrijkste van dit hoofdstuk is het onderscheid tussen een \textit{functie}, als rekenvoorschrift of uitgestelde berekening, en de toepassing (of ``aanroep'') van die functie, waarbij die berekening uitgevoerd wordt. (\textit{wanneer de omvattende berekening uitgevoerd wordt}) (\textit{Ook: denken in termen van het effect van de functie, in plaats van de implementatie}).

We introduceren een eenvoudig rekenmodel, waarbij een expressie via het invullen van waarden stapsgewijs uitgerekend wordt tot een enkele waarde.

Ook: functie als \textit{abstractie}, kunnen werken met een functie op basis van de \textit{specificatie} van die functie, zonder kennis van de definitie (implementatie).

Belangrijke begrippen hierbij zijn: waarden, namen (gekoppeld aan waarden), functie-specificatie (interface): parameters, resultaat; functie-toepassing (``aanroep''), op bepaalde argument-waarden; functie-definitie. (functie als afbeelding?)

\textbf{Hogere-orde functies.}

Belangrijke begrippen: lambda-expressie (anonieme functies). Functie als parameter. Functie als resultaat. \texttt{map}, \texttt{fold} (of \textit{reduce}), \texttt{filter}; lijst-waarden; partiële evaluatie, Currying.

\textbf{Zelf-gedefinieerde data-types.}

\textit{Structuur het een functie volgt de structuur van het data-type (van het argument).}

\textbf{Recursieve data-types en recursieve functies.}

\textit{Structuur van de (recursieve) functie volgt de structuur van het data-type.}

Een recursieve definitie, van een data-type of van een functie, heeft naast de recursieve alternatieven tenminste één niet-recursief alternatief, om de ``recursie te eindigen''.

\textbf{Lijst als recursief data-type.}

Haskell-lijst als recursief data-type; geparametriseerde (generieke) data-types.
definitie (implementatie) van (generieke) functies als \texttt{map}, \texttt{fold} en \texttt{filter}.

\textbf{Bomen}

Binaire bomen, zoekbomen, afdrukken van bomen; flatten, opbouwen van bomen; (B-trees?)