{"version":"1","records":[{"hierarchy":{"lvl1":"Begrippen"},"type":"lvl1","url":"/begrippen","position":0},{"hierarchy":{"lvl1":"Begrippen"},"content":"(elementaire) waarde\n\nGetallen (Int, Float, enz.), logische waarden (False en True), tekens ('A', '%', ' ', enz.)\n\n(samengestelde) waarde\n\nlijst, tupel, of waarde van een zelf-gedefinieerd data-type\n\ndatatype definitie\n\ndefinitie van een datatype door opsomming van de alternatieven; elk alternatief heeft een naam (constructor) en mogelijk extra waarden.\n\nfunctie\n\ngeparametriseerde berekeningsvoorschrift (uitgestelde berekening)zie functie-definitie, functie-toepassing.","type":"content","url":"/begrippen","position":1},{"hierarchy":{"lvl1":"Inleiding"},"type":"lvl1","url":"/inleiding","position":0},{"hierarchy":{"lvl1":"Inleiding"},"content":"het doel van de module is kennismaking met Functioneel Programmeren, als programmeer-paradigma\n\nwe gebruiken hierbij Haskell als voorbeeld-taal;\n\ndeze module is geen inleiding in Haskell, veel aspecten van deze taal laten we buiten beschouwing\n\n","type":"content","url":"/inleiding","position":1},{"hierarchy":{"lvl1":"Waarden en functies"},"type":"lvl1","url":"/nb1","position":0},{"hierarchy":{"lvl1":"Waarden en functies"},"content":"(Inleiding)\n\n","type":"content","url":"/nb1","position":1},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Waarden, namen en expressies"},"type":"lvl2","url":"/nb1#waarden-namen-en-expressies","position":2},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Waarden, namen en expressies"},"content":"\n\nBegrippen\n\nwaarde, operator, expressie, prioriteit van operatoren (of “sterkte van binding”), naam (-definitie, -gebruik), lokale namen (let-constructie).\n\nAls eerste stap in de kennismaking met functioneel programmeren beginnen we erg eenvoudig: met waarden, zoals gehele getallen, en expressies waarin je (invoer)waarden gebruikt om nieuwe (uitvoer)waarden te berekenen.\n\nEen enkelvoudige waarde is een getal, een teken (character), of een logische waarde (False of True).\n\nVoorlopig gebruiken we alleen gehele getallen.\nLater zullen we kennismaken met tekens, logische waarden, floating point getallen, en samengestelde waarden, zoals strings en lijsten.\n\nIn een expressie kunnen we waarden combineren met operatoren en functies, om daarmee nieuwe waarden uit te rekenen. De gebruikelijke operatoren zijn: + - * voor optellen, aftrekken en vermenigvuldigen. Voor het delen van gehele getallen hebben we de functies div en mod. Vermenigvuldigen en delen hebben een grotere prioriteit dan optellen en aftrekken, alweer zoals we gewend zijn. We kunnen haakjes gebruiken om de prioriteit (volgorde van berekenen) expliciet aan te geven.\n\nOpmerking. Operatoren blijken in Haskell ook gewoon functies te zijn; daar komen we later op terug.\n\nVoorbeelden van expressies\n\n3 + 4 * 5\n\n\n\n(3 + 4) * 5\n\n\n\nOpdracht. Geef voor bovenstaande expressies aan wat de waarden zijn en wat de operatoren.\n\n","type":"content","url":"/nb1#waarden-namen-en-expressies","position":3},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Namen: definitie en gebruik"},"type":"lvl2","url":"/nb1#namen-definitie-en-gebruik","position":4},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Namen: definitie en gebruik"},"content":"\n\nWe kunnen een waarde een naam geven (definiëren), en die naam later gebruiken waar we de waarde nodig hebben. Bij het uitrekenen van een expressie vervangen we een naam dan door de waarde die aan die naam gekoppeld is.\n\nIn een functionele taal als Haskell mag een naam precies één keer gedefinieerd zijn: je kunt in eenzelfde programma die naam geen andere waarde geven. a is dus geen variabele in de zin van “gewone” programmeertalen, het is meer zoals een naam in de wiskunde die een enkele waarde voorstelt.\n\nlet op: namen van waarden en van functies moeten in Haskell met een kleine letter beginnen.\n\na = 3   -- definitie van a\n\n\n\na + 4 * 5  -- gebruik van a\n\n\n\nb = 4 * 5 -- definitie van b\n\n\n\na + b  -- gebruik van a en b\n\n\n\nOpmerking. Wanneer reken je de expressie in de definitie van b uit? In onze voorbeelden gaan we ervan uit dat je eerst de expressie uitrekent, en de resultaat-waarde gebruikt als definitie van b. Maar: in Haskell maakt dat niet uit, omdat je een naam maar éénmaal een waarde mag geven: je zou de berekening ook later kunnen uitvoeren (lazy evaluation).\n\nEen expressie beschrijft een berekening. Deze berekening kun je met de hand uitvoeren, waarbij je elke stap uitlegt wat je doet.\n\nVoorbeeld:\n\n    2 * a + b\n==     {vervang a door de bijbehorende waarde: 3}\n    2 * 3 + b\n==     {rekenen}\n    6 + b\n==     {vervang b door 20}\n    6 + 20\n==     {rekenen}\n    26\n\nDit blijkt te kloppen met het Haskell-resultaat\n\n2 * a + b\n\n\n\nBovenstaande uitwerking lijkt erg omslachtig, maar we zullen later voorbeelden zien waarin zulke berekeningen kunnen helpen om programma’s te begrijpen.\n\n","type":"content","url":"/nb1#namen-definitie-en-gebruik","position":5},{"hierarchy":{"lvl1":"Waarden en functies","lvl3":"Lokale namen: let","lvl2":"Namen: definitie en gebruik"},"type":"lvl3","url":"/nb1#lokale-namen-let","position":6},{"hierarchy":{"lvl1":"Waarden en functies","lvl3":"Lokale namen: let","lvl2":"Namen: definitie en gebruik"},"content":"\n\nDe namen a en b die we hierboven gedefinieerd hebben, hebben betekenis voor het hele programma. Het zijn *globale namen. Met de let-constructie kun je een lokale naam definiëren: deze heeft alleen betekenis in de let-expressie:\n\nlet <naam> = <waarde> in <expressie met naam>\n\nVoorbeeld:\n\nlet x = 20 in x + 3\n\n\n\nDeze lokale naam x heeft buiten de let-constructie geen betekenis:\n\nx\n\n\n\nOmdat de lokale naam buiten de let-constructie geen betekenis heeft, hadden we ook een andere naam kunnen gebruiken:\n\nlet zzz = 20 in zzz + 3\n\n\n\n","type":"content","url":"/nb1#lokale-namen-let","position":7},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Functies: definitie en toepassing"},"type":"lvl2","url":"/nb1#functies-definitie-en-toepassing","position":8},{"hierarchy":{"lvl1":"Waarden en functies","lvl2":"Functies: definitie en toepassing"},"content":"\n\nBegrippen\n\nfunctie-definitie\n\nfunctie-naam\n\nfunctie-parameter - als lokale naam\n\nfunctie-expressie (“body”), met daarin de parameter\n\ntoepassing van een functie op een (argument)waarde\n\nIn de voorbeelden hierboven staan de namen a en b voor getallen.\nMaar, we kunnen een naam ook koppelen aan een functie.\n\nde definitie van een functie koppelt de functie-naam aan een functie-waarde (expressie)\n\nfunctie-definitie. Als eerste voorbeeld van een functie definiëren we de functie sqr, voor het kwadrateren van een getal. De gebruikerlijke wiskundige hiervan definitie is:f(x) = x * x\n\nIn Haskell wordt dit:\n\nsqr x = x * x\n\n\n\nDeze regel definieert de naam sqr als de naam van de functie, met één parameter, die we hier x noemen. De definitie koppelt de naam sqr aan de geparametriseerde expressie, x * x.\n\nDe naam van de parameter x heeft alleen betekenis in de functie-definitie. We kunnen deze definitie ook schrijven als: sqr y = y * y of als sqr abc = abc * abc.\n\nMerk op dat we hier geen haakjes gebruiken, in tegenstelling tot de wiskundige defintie.\n\nfunctie-toepassing. We kunnen een functie toepassen op een waarde.\n\nDe functie sqr toegepast op de waarde 3 schrijven we in Haskell als: sqr 3\n\nDe waarde waarop de functie toegepast wordt heet ook wel de argument-waarde.\n\nVoor functie-toepassing (Engels: function application) gebruik je in Haskell geen haakjes, net als in de definitie. In veel andere programmeertalen schrijf je: sqr(3) - net is meestal in de wiskunde.\n\nFunctie-toepassing in Haskell bindt sterker dan de operatoren: sqr 3 + 4 lees je dan als (sqr 3) + 4. (Ga dit na.) Dit is dus iets anders dan sqr (3 + 4).\n\nDe toepassing van deze functie op een argument, bijvoorbeeld sqr 7, resulteert in de expressie (berekening) waarin de waarde van het afgument ingevuld is in de definiërende expressie van de functie, hier sqr:    sqr 7\n==    {functie-toepassing sqr: vervang de naam door de definiërende expressie}\n    let x = 7 in x * x\n==    {vervang x door waarde: 7}\n    7 * 7\n==    {rekenen}\n    49\n\nsqr 7\n\n\n\nVoorbeeld. In het onderstaande voorbeeld gebruiken we een expressie als argument voor de sqr-functie. In dit geval moeten we haakjes gebruiken voor deze expressie, omdat functie-applicatie sterker “bindt” dan optelling (of andere operatoren). De notatie sqr a + 2 moet je dan lezen als (sqr a) + 2. Ga dit na.\n\nsqr a - 10\n\n\n\nAls je een andere volgorde (prioriteit) wilt afdwingen gebruik je haakjes:\n\nsqr (a - 10)\n\n\n\nMogelijke voorbeelden:\n\ndouble\n\nsucc\n\nisEven\n\n(omzetten van hoofd- in kleine letters of omgekeerd)\n\nsqr (a + 2)\n\n\n\nWe rekenen deze expressie uit door eerst de argument-expressie a + 2 uit te rekenen:\n\n    sqr (a + 2)\n==     {invullen waarde van a}\n    sqr (3 + 2)\n==     {rekenen}\n    sqr 5\n==     {invullen definitie van sqr}\n    let x = 5 in x * x\n==     {invullen waarde van x}\n    5 * 5\n==     {rekenen}\n    25\n\n\n\n\n\nWe kunnen de volgorde van de verschillende stappen ook anders kiezen, bijvoorbeeld:\n\n    sqr (a + 2)\n==     {invullen definitie van sqr}\n    let x = a + 2 in x * x\n==     {invullen van waarde van x}\n    (a + 2) * (a + 2)\n==     {invullen van waarde van a}\n    (3 + 2) * ( 3 + 2)\n==     {rekenen}\n    5 * 5\n==     {rekenen}\n    25\n\nMerk op dat we hetzelde resultaat krijgen als eerder. In een functionele taal maakt de volgorde van de stappen geen verschil voor het resultaat, omdat de waarde bij een naam nooit verandert. Maar deze volgorde kan wel verschil maken voor de hoeveelheid rekenwerk. In dit laatste voorbeeld moesten we bijvoorbeeld de uitdrukking 3 + 2 tweemaal uitrekenen.\n\nIn het vervolg hanteren we steeds de regel: eerst de argumenten uitreken, daarna de functie-definitie invullen. Deze manier van het gebruik van functies heet strict evaluation. Dit is de aanpak die de meeste programmeertalen gebruiken, ook veel functionele talen.\n\nHaskell zelf gebruikt een andere aanpak: een expressie wordt pas uitgerekend als het resultaat nodig is, bijvoorbeeld omdat dit afgedrukt moet worden. Deze aanpak heet lazy evaluation. We zullen daar later voorbeelden van laten zien, en gevallen waar dit extra gemak geeft.\n\n\n\n\n\n","type":"content","url":"/nb1#functies-definitie-en-toepassing","position":9},{"hierarchy":{"lvl1":"Waarden en functies","lvl3":"Functies met meerdere parameters","lvl2":"Functies: definitie en toepassing"},"type":"lvl3","url":"/nb1#functies-met-meerdere-parameters","position":10},{"hierarchy":{"lvl1":"Waarden en functies","lvl3":"Functies met meerdere parameters","lvl2":"Functies: definitie en toepassing"},"content":"\n\nEen voorbeeld van een functie met meerdere parameters:\n\nadd x y = x + y\n\n\n\nDeze functie pas je toe door twee argument-waarden na de functienaam te plaatsen:\n\nadd 3 (4*5)\n\n\n\nMerk op: geen haakjes, geen komma. Maar wel haakjes voor de expressie 4*5, omdat functie-applicatie sterker bindt dan vermenigvuldigen. Zonder deze haakjes zou de betekenis zijn: (add 3 4) * 5 (ga dit na)","type":"content","url":"/nb1#functies-met-meerdere-parameters","position":11},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties"},"type":"lvl1","url":"/nb10","position":0},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties"},"content":"We hebben in het vorige hoofdstuk gezien hoe je kunt werken met recursieve zelf-gedefinieerde data-types. De structuur van de operaties daarvoor volgt de structuur van het data-type.\n\nLijsten in Haskell zijn op dezelfde manier gemaakt. We behandelen eerst zelf-gedefinieerde lijsten van Ints. Daarna laten we zien hoe Haskell-lijsten werken met elementen van een willekeurig type.\n\ndata List = Empty | Cons Int List\n\n\n\nEen functie op zo’n List volgt de structuur van deze List, bijvoorbeeld:\n\nlength :: List -> Int\nlength Empty = 0\nlength (Cons x xs) = 1 + (length xs)\n\n\n\nlength (Cons 3 (Cons 4 (Cons 5 Empty)))\n\n\n\nlst1 = (Cons 3 (Cons 4 (Cons 5 Empty)))\n\n\n\nlength lst1 \n\n\n\n","type":"content","url":"/nb10","position":1},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Lijsten in Haskell"},"type":"lvl2","url":"/nb10#lijsten-in-haskell","position":2},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Lijsten in Haskell"},"content":"\n\nLijsten in Haskell zijn op dezelfde manier gedefinieerd:data [a] = [] \n         | a:[a]\n\nof ook wel, als we de operator : (cons) als functie schrijvendata [a] = []\n         | (:) a [a]\n\nmet andere woorden:\n\n[] is de lege lijst\n\n: is de cons-operator (constructor)\n\nIn dit geval is a een type-parameter: het eigenlijke type is nog niet bekend, maar het type moet links en rechts consistent gebruikt worden. Dit betekent dat alle elementen in de lijst van hetzelfde type moeten zijn.\n\nBovenstaande lijst-definitie is ingebouwd in Haskell, o.m. vanwege de notatie van lijst-waarden als [1,3,5]. We kunnen deze notatie niet zelf definiëren. Maar type-parameters kunnen we ook zelf gebruiken, en daarmee onze eigen generieke lijsten maken (zie verderop).\n\nAan de hand van deze data-type definitie kunnen we nu lijst-functies definiëren, waarbij we de structuur van de lijst-waarde terugzien in de functie-definitie.\nIn het type van de functie zien we, net als in de definitie van het datatype, ook weer de type-parameter terug\n\nlength :: [a] -> Int\nlength [] = 0\nlength (x:xs) = 1 + (length xs)\n\n\n\nlength \"noot\"\n\n\n\nOpmerking de laatste regel van length kun je ook schrijven als:length ((:) x xs) = 1 + (length xs)\n\nDaarmee laat je duidelijk zien dat : (“cons”) een “normale” constructor is: een functie die een waarde van het betreffende type (list) construeert.\n\nMerk op:\n\nde definitie van de recursieve functie length volgt de structuur van het data-type\n\neen recursieve functie heeft, naast één of meer recursieve alternatieven, altijd een niet-recursief alternatief, “om de recursie te stoppen”\n\nOp eenzelfde manier kunnen we een functie schrijven voor het sommeren van alle elementen van een Int-lijst:\n\nsum :: [Int] -> Int\nsum [] = 0\nsum (x:xs) = x + (sum xs)\n\n\n\nsum [1,2,3]\n\n\n\nMerk op dat we deze sum-functie niet voor lijsten van een willekeurig type kunnen definiëren: de + operator is alleen gedefinieerd voor getallen. We hebben deze functie nu alleen gedefinieerd voor gehele getallen.\n\nWe zullen later zien hoe je zo’n functie kunt definiëren voor lijsten van getallen: Int, Float, enz.\n\n","type":"content","url":"/nb10#lijsten-in-haskell","position":3},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Geparametriseerde types"},"type":"lvl2","url":"/nb10#geparametriseerde-types","position":4},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Geparametriseerde types"},"content":"Hierboven hebben we het lijst-data type gezien geparametriseerd met een type. Ook de lijst-functies hebben een geparametriseerd type.\n\nWe kunnen ons zelf-gedefinieerde lijst-type ook op een dergelijke manier parametriseren met een type, net als de functies die we daarvoor definiëren.\n\ndata List a = Empty | Cons a (List a)\n\n\n\nlength :: List a -> Int\nlength Empty = 0\nlength (Cons x xs) = 1 + (length xs)\n\n\n\nlength (Cons 'n' (Cons 'o' (Cons 'o' (Cons 't' Empty))))\n\n\n\nlength (Cons 3 (Cons 4 (Cons 5 Empty)))\n\n\n\n","type":"content","url":"/nb10#geparametriseerde-types","position":5},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl3":"map, fold","lvl2":"Geparametriseerde types"},"type":"lvl3","url":"/nb10#map-fold","position":6},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl3":"map, fold","lvl2":"Geparametriseerde types"},"content":"\n\nWe definiëren hier map en fold als generieke functies, die voor alle soorten lijsten gebruikt kunnen worden. In de typering van de functie gebruiken we daarvoor type-parameters, in plaats van concrete types als Int of [Char].\n\n(We gebruiken hier de namen mapx en foldx, om mogelijke verwarring met de ingebouwde functies te voorkomen.)\n\nmapx :: (a -> b) -> [a] -> [b]\nmapx f [] = []\nmapx f (x:xs) = (f x) : (mapx f xs)\n\n\n\nmapx (\\x -> x*2) [1,2,3]\n\n\n\nimport Data.Char\n\n\n\nmapx toUpper \"aap\"\n\n\n\nBij de fold-functie moeten we er rekening mee houden dat het type van het resultaat kan verschillen van het type van de lijst-elementen; bijvoorbeeld als we fold gebruiken om het aantal tekens in een string te tellen. De string is een lijst van tekens - [Char], en het resultaat is een Int.\n\nfold heeft als parameters:\n\neen functie met twee parameters: a -> b -> b\n\neen nul-element (bij die functie, voor de lege lijst), van type b\n\neen lijst van a-elementen: [a]\n\nfoldx :: (a -> b -> b) -> b -> [a] -> b\nfoldx f y [] = y\nfoldx f y (x:xs) = f x (foldx f y xs)\n\n\n\nfoldx (+) 0 [1,2,3]\n\n\n\nIn het onderstaande geval is het type van de lijst: [Char], en het type van het resultaat: Int. In termen van de type-parameters van foldx: a == Char, b == Int.\n\nfoldx (\\x y -> y + 1) 0 \"aap\"\n\n\n\n","type":"content","url":"/nb10#map-fold","position":7},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Opdrachten"},"type":"lvl2","url":"/nb10#opdrachten","position":8},{"hierarchy":{"lvl1":"Lijsten en lijst-operaties","lvl2":"Opdrachten"},"content":"\n\ndefinieer de volgende functies op lijsten (zonder gebruik van ingebouwde lijst-functies):\n\nprod (mul)\n\nreverse\n\nsqr (waarbij alle elementen gekwadrateerd worden)","type":"content","url":"/nb10#opdrachten","position":9},{"hierarchy":{"lvl1":"Bomen"},"type":"lvl1","url":"/nb11","position":0},{"hierarchy":{"lvl1":"Bomen"},"content":"import Data.Char\n\n\n\nOp eenzelfde manier als we lijsten gedefinieerd hebben, kunnen we ook bomen definiëren. We beginnen met binaire bomen. Later breiden we dit uit tot n-aire bomen.\n\nWe definiëren een generieke binaire boom: de elementen in de boom moeten van eenzelfde type zijn, maar dat kan verder een willekeurig type zijn.\n\ndata Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show)\n\n\n\ntmap :: (a -> b) -> (Tree a) -> (Tree b)\ntmap f Nil = Nil\ntmap f (Node x lt rt) = Node (f x) (tmap f lt) (tmap f rt)\n\n\n\ntree1 = Node 1 (Node 2 Nil Nil) (Node 3 (Node 4 Nil Nil) Nil)\n\n\n\ntree2 = Node \"aap\" (Node \"noot\" (Node \"mies\" Nil Nil) Nil) (Node \"teun\" (Node \"vuur\" Nil Nil) Nil)\n\n\n\ntmap (\\x -> x*x) tree1\n\n\n\nupper :: [Char] -> [Char]\nupper [] = []\nupper (x:xs) = (toUpper x) : (upper xs)\n\n\n\nupper \"aap\"\n\n\n\ntmap upper tree2\n\n\n\nFlatten We kunnen een boom “platslaan”: we plaatsen alle knoop-elementen dan in een lijst.\n\nWe kunnen een boom op verschillende manieren platslaan: prefix, infix, of postfix. We gebruiken eerst de “prefix”, waarbij de volgorde van de knopen gelijk blijft aan die in de definitie (die ook prefix is).\n\nflatten :: (Tree a) -> [a]\nflatten Nil = []\nflatten (Node x lt rt) = x : ((flatten lt) ++ (flatten rt))\n\n\n\nflatten tree1\n\n\n\nflatten tree2\n\n\n\nDe fold voor bomen is wat lastiger...\n\ntfold :: (a -> b -> b) -> b -> (Tree a) -> b\ntfold f y Nil = y\n...\n\n*N-aire bomen\n\ntype Ntree1 a = (a, [Ntree1 a])\n\n\n\n(Merk op dat in dit geval de boom altijd tenminste 1 knoop heeft... met een waarde.)\n\nAlternatief:\n\ndata Ntree a = Nnil | Nnode a [Ntree a]\n\n","type":"content","url":"/nb11","position":1},{"hierarchy":{"lvl1":"Een voorproefje van functioneel programmeren in Haskell"},"type":"lvl1","url":"/nb2","position":0},{"hierarchy":{"lvl1":"Een voorproefje van functioneel programmeren in Haskell"},"content":"Je kunt Haskell als een rekenmachine gebruiken: je kunt expressies invoeren in de gebruikelijke notatie.\n\nDenk erom dat je, zoals in alle programmeertalen, vermenigvuldiging altijd moet uitschrijven met de *=operator.\n\n3 + 4\n\n\n\n3 + 4 * 5\n\n\n\n(3 + 4) * 5\n\n\n\nJe kunt een waarde ook een naam geven, en die naam gebruiken op de plek van een waarde in een expressie:\n\na = 3\n\n\n\na + 4\n\n\n\nNaast getallen als waarde kun je ook tekens (chars) en strings gebruiken. (Later)\n\nEen functie-definitie ziet er vrijwel net zo uit als in de wiskunde:\n\nsqr x = x * x\n\n\n\nAls je nu de waarde van sqr opvraagt, krijg een foutmelding: je kunt een functie-waarde niet afdrukken.\n\nsqr\n\n\n\nDe aanroep (de “applicatie” ofwel het gebruik) van een functie schrijf je als de naam van de functie direct gevolgd door het argument. Je hebt geen haakjes nodig.\n\nsqr 3\n\n","type":"content","url":"/nb2","position":1},{"hierarchy":{"lvl1":"Typering en lijsten"},"type":"lvl1","url":"/nb3","position":0},{"hierarchy":{"lvl1":"Typering en lijsten"},"content":"Tot nu toe hebben we alleen gewerkt met gehele getallen als waarden.\nMaar Haskell biedt meerdere soorten waarden, zoals floating point getallen, tekens (characters),\nstrings, tupes., lijsten, enz.\n\nHet type van een waarde geeft de soort aan. Het type van een waarde bepaalt welke operaties (functies, operatoren) er voor die waarde mogelijk zijn. Door deze typering kan het Haskell systeem  controleren of in een berekening de waarden en de operaties bij elkaar passen. Je kunt bijvoorbeeld niet een string optellen bij een getal: optellen (+) is alleen gedefinieerd voor getallen.\n\n3 + 'a'\n\n\n\nWe hebben in Haskell te maken met:\n\nelementaire waarden, zoals getallen, tekens, en boolean waarden;\n\nsamengestelde waarden, zoals lijsten en tupels;\n\nfunctie-waarden;\n\nwaarden van zelf-gedefinieerde data-types.\n\nIn dit hoofdstuk behandelen we de eerste twee. In de volgende hoofdstukken komen de andere types en waarden aan de orde.\n\nElementaire waarden.\n\ntype: Int - voorbeeld: 31415926\n\ntype: Float - voorbeeld: 3.1415926, 2.3e5\n\ntype Char - voorbeeld: 'A', '#'\n\ntype Bool - voorbeelden: False, True\n\nAls je een naam definieert, zoals in a = 10, dan bepaalt het Haskell-systeem het type van de naam op basis van het type van de waarde (expressie).\n\nSamengestelde waarden.\n\nEen samengestelde waarde bevat (mogelijk meerdere) waarden van andere types. Voorbeelden van samengestelde waarden zijn lijsten en tupels.\n\nLijsten.\n\neen lijst bevat 0 of meer waarden van eenzelfde type\n\nals a een type is, dan is [a] het type van een “lijst van a-waarden”\n\n[] - de lege lijst\n\n[1, 3, 5]  - lijst van gehele getallen -  type: [Int]\n\n[3.4, 120e10, -7.5] - lijst van floating point getallen - type: [Float]\n\n['a', 'b', '*'] - lijst van tekens - type: [Char]\n\nDeze laatste waarde kun je ook schrijven als \"ab*\". Het type [Char] noemen we meestal String.\n\nIn deze voorbeelden hebben we alleen letterlijke waarden in de lijsten opgenomen. Maar je kunt de elementen van een lijst ook uitrekenen met expressies (van het juiste type), bijvoorbeeld: [1, a*12, abs (b - 7)]\n\n['a', 'b', '*']\n\n\n\nVerkorte notatie. Voor lijsten met opeenvolgende gehele getallen is er een speciale verkorte notatie: [a..b] staat voor een lijst met alle getallen van a tot en met b. Bijvoorbeeld: [3..6] = [3,4,5,6].\n\nEen andere beknopte manier om een lijst te genereren is met behulp van list comprehension, zie XXXX.\n\nLijst-constructor: cons. De operator : (spreek uit: cons) kun je gebruiken om een element op kop van een lijst toe te voegen, bijvoorbeeld: 3 : [5, 7] geeft [3, 5, 7].\n\nJe kunt de lijst [3, 5, 7] dan zien als een verkorte notatie voor: 3 : (5 : (7 : []))) of korter: 3 : 5 : 7 : []. (De lijst-constructor cons is rechts-associatief.)\n\n[3..12]\n\n\n\nOperaties op lijsten\n\nWat kun je met lijsten? Welke opdrachten/functies zijn mogelijk?\n\naaneenrijgen (concatenatie): ++ - voorbeeld: [1, 2] ++ [3, 4] of \"aap\" + \"noot\" + \"mies\"\n\nkop-element van een lijst: head \"aap\"\n\nstaart van een lijst: tail \"aap\"\n\nlengte van een lijst: length \"aap\"\n\nomkeren van een lijst: reverse \"aap\"\n\n[3 ,4] ++ [1, 2]\n\n\n\n4 : 5 : [9, 10]\n\n\n\n\"aap\" ++ \"noot\" ++ \"mies\"\n\n\n\nhead \"aap\"\n\n\n\ntail \"aap\"\n\n\n\nlength \"aap\"\n\n\n\nreverse \"aap\"\n\n\n\nTupels\n\nSoms heb je twee of drie (of meer) waarden die bij elkaar horen, en eigenlijk één waarde vormen. Denk bijvoorbeeld aan de coördinaten in een 2-dimensionale ruimte. Hiervoor kun je een tupel gebruiken, in dit geval een paar of 2-tupel. Het aantal waarden ligt vast, en is klein, maar de waarden hoeven niet van eenzelfde type te zijn.\n\nEen tupel schrijf je door de waarden tussen haakjes te schrijven, gescheiden door komma’s. Voorbeelden:\n\n(10, 20) -- heeft type (Int, Int)\n\n('a', 75) -- heeft type (Char, Int)\n\n(1.0, 4, 3.4)-- heeft type (Float, Int, Float)\n\nEen waarde in een tupel kan ook een samengestelde waarde zijn. Je kunt op die manier tupels en strings combineren, bijvoorbeeld:\n\neen tupel met lijsten ([1, 7] , \"aap\") -- heeft type ([Int], [Char])\n\neen lijst met tupels: [('a', 7), ('b', 35)]-- heeft type [(Char, Int)]\n\nWe hebben gezien dat je met de ( , , ) - notatie een tupel construeert uit samenstellende waarden. Je kunt op de volgende manieren een tupel de-construeren tot de samenstellende waarden:\n\nvia het benoemen van de elementen:\n\nlet (a, b) = ('x', 37) in b * 2\n\nvia de functies fst, snd (alleen voor 2-tupels ofwel paren)\n\nlet b = snd ('x', 37) in b * 2\n\n","type":"content","url":"/nb3","position":1},{"hierarchy":{"lvl1":"Typering en lijsten","lvl2":"Typering van functies"},"type":"lvl2","url":"/nb3#typering-van-functies","position":2},{"hierarchy":{"lvl1":"Typering en lijsten","lvl2":"Typering van functies"},"content":"\n\nHet type van een functie beschrijft de types van de parameter(s) en van het resultaat.\nDoor het type bij een functie te vermelden verduidelijk je (voor een deel) hoe die functie gebruikt kan worden, en voorkom je sommige fouten in het gebruik van de functie.\n\nDe notatie: double :: Int -> Int geeft aan:\n\ndat double functie is (door de pijl: ->)\n\nmet een Int-waarde als parameter (het type voor de pijl)\n\nen een Int-waarde als resultaat (het type na de pijl)\n\nAnders gezegd: double is een functie van Int (domein) naar Int (bereik).\n\ndouble :: Int -> Int\ndouble x = x + x\n\n\n\ndouble 8\n\n\n\nToepassing van de functie double op een niet-Int argument geeft een foutmelding:\n\ndouble 'A'\n\n\n\n","type":"content","url":"/nb3#typering-van-functies","position":3},{"hierarchy":{"lvl1":"Functies als waarden"},"type":"lvl1","url":"/nb4","position":0},{"hierarchy":{"lvl1":"Functies als waarden"},"content":"In dit hoofdstuk maak je kennis met functies als waarden. Een functie kan overal gebruikt worden waar je een “normale” waarde zoals een getal of een string kunt gebruiken:\n\neen functie kan optreden als parameter van een andere functie;\n\neen functie kan optreden als resultaat van een functie;\n\neen functie kan onderdeel zijn van een samengestelde datastructuur, zoals een lijst;\n\nje kunt “rekenen met functies”, bijvoorbeeld door de compositie van twee functies.\n\nJe kunt ook anonieme functie-waarden kunt hebben: een functie-waarde hoeft niet beslist een naam te hebben, net zomin als elke getalwaarde of string een naam hoeft te hebben.\n\n","type":"content","url":"/nb4","position":1},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Lambda-expressies: anonieme functie-waarden"},"type":"lvl2","url":"/nb4#lambda-expressies-anonieme-functie-waarden","position":2},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Lambda-expressies: anonieme functie-waarden"},"content":"Tot nu toe hebben we functie-definities gezien van de vorm: sqr x = x * x. Dit lijkt nog niet op de vorm van andere naam-waarde koppelingen, zoals a = 42. De waarde 42 is hier een anonieme waarde, die in deze definitie gekoppeld wordt aan een naam.\n\nEen lambda-expressie beschrijft een anonieme functie: deze bestaat alleen uit de parameters en de definiërende expressie. Bijvoorbeeld:\\ x -> x * x\n\nHet symbool \\ spreek je uit als lambda, zie ook de gelijkenis met de griekse letter \\lambda. Het pijltje -> kun je uitspreken als naar of geeft. Merk de overeenkomst op tussen deze lambda-expressie en de notatie voor een functie-type.\n\nWat kun je met zo’n anonieme functie-expressie (of eigenlijk: functie-waarde)? Deze kun je gebruiken overal waar je een functie-waarde verwacht: in functie-definities, parameters of resultaten, enz.\n\nHiermee kunnen we de definitie van een functie schrijven op dezelfde manier als een “normale” naam-waarde definitie:sqr :: Int -> Int\nsqr = \\ x -> x * x\n\nDe toepassing van een functie op een argument kun zien als het vervangen van de \\ door let, met de parameter-naam gekoppeld aan het argument; en het pijltje -> vervangen door in    sqr 7\n==    {invullen waarde van sqr}\n    (\\ x -> x * x) 7\n==    {functie-toepassing op argument 7)\n    let x = 7 in x * x\n==    {invullen waarde van  x}\n    7 * 7\n==    {rekenen}\n    49\n\nsqr :: Int -> Int\nsqr = \\ x -> x * x\n\n\n\nsqr 7\n\n\n\n(\\ y -> y * y) 7\n\n\n\nOpdracht Definieer de functie double met een lambda-expressie.\n\nfuncties en lambda-expressies met meerdere parameters\n\nEen lambda-expressie kan ook meerdere parameters hebben:add :: Int -> Int -> Int\nadd = \\ x y -> x + y\n\nadd :: Int -> Int -> Int\nadd = \\ x y -> x + y\n\n\n\nadd 3 4\n\n\n\n","type":"content","url":"/nb4#lambda-expressies-anonieme-functie-waarden","position":3},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als operator, operator als functie"},"type":"lvl2","url":"/nb4#functie-als-operator-operator-als-functie","position":4},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als operator, operator als functie"},"content":"\n\nEen functie met twee parameters, zoals add hierboven, kun je ook als (binaire) operator tussen de parameters noteren, zoals een + of * operator. Je gebruikt daarvoor “backticks” (```) rond de naam.3 `add` 4 `add` 5\n\nAlleen de notatie verandert, het principe van functie-aanroep blijft gelijk.\n\n3 `add` 4 `add` 5\n\n\n\nOperatoren als functie. Je kunt een operator, zoals + ook als functie gebruiken, door deze tussen haakjes te plaatsen: (+). bijvoorbeeld: (+) 3 4\n\n(+) 3 4\n\n\n\nBij ingewikkelder expressies moet je er dan rekening mee houden dat functie-toepassing “links-associatief” is. In de onderstaande expressie is daarom een extra haakjes-paar nodig voor de vermenigvuldiging.\n\n(+) 3 ((*) 4 5)\n\n\n\n","type":"content","url":"/nb4#functie-als-operator-operator-als-functie","position":5},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als parameter: map, reduce, filter"},"type":"lvl2","url":"/nb4#functie-als-parameter-map-reduce-filter","position":6},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als parameter: map, reduce, filter"},"content":"Soms wil je een functie toepassen op alle waarden in een datastructuu, zoals een lijst.\nHiervoor heb je in Haskell (en andere talen) de functie map die zowel een functie als een lijst als parameter heeft: deze map past de betreffende functie toe op alle elementen van de lijst:\n\nmap f [a, b, c, ...] = [f a, f b, fc, ...]\n\nHet type van map voor Int-lijsten kun je dan zien als: map :: (Int -> Int) -> [Int] -> [Int]\nDe eerste parameter is een functie, de tweede is een Int-lijst, het resultaat is ook weer een Int-lijst.\n\nsqr :: Int -> Int\nsqr x = x * x\n\n\n\nVoorbeeld    map sqr [1,3,7]\n==    {\"definitie\" map invullen}\n    [sqr 1, sqr 3, sqr 7]\n==    {definitie sqr invullen}\n    [let x=1 in x*x, let x=3 in x*x, let x=7 in x*x]\n==    {definitie (waarde) van x invullen}\n    [1*1, 3*3, 7*7]\n==    {rekenen}\n    [1, 9, 49]\n\nmap sqr [1, 3, 7]\n\n\n\ndouble :: Int -> Int\ndouble x = x + x\n\n\n\nmap double [1..10]\n\n\n\nJe kunt ook een anonieme functie (lambda expressie) meegeven aan map:\n\nmap (\\x -> x * x * x) [1..10]\n\n\n\nfoldl, foldr Een andere veel voorkomende operatie is om een functie tussen alle elementen van een lijst uit te voeren, bijvoorbeeld het optellen van alle elementen.\n\n[1, 3, 7] -> 1 + 3 + 7 -> 11\n\nAls de lijst leeg is, is het resultaat 0 (voor optelling). Eigenlijk kun je bovenstaande dan schrijven als:\n\n[1, 3, 7] -> 1 + 3 + 7 + 0 -> 11\n\n(Wat is de waarde die je moet gebruiken voor het vermenigvuldigen van alle elementen van een lijst? Anders gezegd: welke bijdrage levert de lege lijst aan de totale vermenigvuldiging?)\n\nDe functie foldl (fold left) in Haskell past een operator f (functie met 2 parameters) toe tussen alle elementen van een lijst, waarbij het resultaat voor de lege lijst gelijk is aan de “nul-waarde” z:foldl :: (Int -> Int) -> Int -> [Int] - Int\nfoldl f z [a, b, c, ...] = a `f` b `f` c `f` ... `f` z\n\nDit kun je ook zien als het vervangen van de const-constructor : door de functie (operator) f, waarbij de waarde voor de lege lijst gelijk is aan de “nul-waarde” z:foldl f z (a : b : c ... : []) = a `f` b `f` c ... `f` z\n\nVoorbeeld:foldl (+) 0 (1 : 3 : 7 : []) = 1 + 3 + 7 + 0 = 11\n\nDe functie foldl vouwt de lijst wordt eigenlijk “opgevouwen” tot een enkele waarde met behulp van de functie f, vandaar de naam foldl (fold left).\n\nNaast foldl heb je ook foldr (fold right). Het verschil is dat foldl van links naar rechts rekent (links-associatief), en foldr van rechts naar links (rechts-associatief). Voor het optellen van gehele getallen maakt dat geen verschil, maar bij andere functies kan dat een ander resultaat geven.foldl f z (a : b : c ... : []) = ((((a `f` b) `f` c) ...) `f` z)\nfoldr f z (a : b : c ... : []) = (a `f` (b `f` (c `f` (... `f` z))))\n\nreduce In andere programmeertalen heet de functie foldl vaak reduce: deze reduceert een lijst, of een andere datastructuur, tot een enkele waarde.\n\nDe combinatie map/reduce (en soms ook filter) komt tegenwoordig in veel programmeertalen voor: dit maakt het mogelijk om potentieel parallellisme uit te drukken, omdat de volgorde van de afzonderlijke operaties er niet toe doet.\n\nfoldl (\\x y -> x + y) 0 [1..10]\n\n\n\nfoldl (\\x y -> x + y) 0 []\n\n\n\nOperatoren als functie. Je kunt een operator, zoals + ook als functie gebruiken, door deze tussen haakjes te plaatsen: (+). Bovenstaand voorbeeld kun je dan ook schrijven als:\n\n","type":"content","url":"/nb4#functie-als-parameter-map-reduce-filter","position":7},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als resultaat"},"type":"lvl2","url":"/nb4#functie-als-resultaat","position":8},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functie als resultaat"},"content":"\n\nJe kunt een functie-waarde ook gebruiken als resultaat van een functie.\nBestudeer het volgende voorbeeld:addx :: Int -> (Int -> Int)\naddx x = \\ y -> x + y\n\naddtwo = addx 2\n...\naddtwo 9\n\n\nDe functie-toepassing addx 2 heeft als resultaat de functie-waarde \\ y -> 2 + yaddx 2\n\n==    {definitie van addx invullen}\nlet x = 2 in \\ y -> x + y\n==    {definitie van x invullen}\n\\ y -> 2 + y\n\nWe kunnen de definitie van addx ook schrijven als geneste lambda-expressies:addx :: Int -> (Int -> Int)\naddx = \\ x -> (\\ y -> x + y)\n\nDe haakjes rond het resultaat-type en de haakjes rond de geneste lambda-expressie mogen we weglaten, omdat de pijl -> rechts-associatief is:addx :: Int -> Int -> Int\naddx = \\ x -> \\ y -> x + y\n\nDe functie addx is nu eigenlijk een gewone functie met twee parameters. Als je alleen het eerste argument opgeeft, krijg je een functie die je later op het tweede argument kunt toepassen.\n\nAlle functies met twee of meer parameters kunnen we beschouwen als geneste lambda-expressies. We kunnen de functies partieel parametriseren, door deze toe te passen op 1 argument: we krijgen dan een functie die we later op de volgende argumenten kunnen toepassen.\n\nHet verschijnsel dat je functies met meerdere parameters kunt beschouwen als geneste lambda-expressies, die je partieel kunt parametriseren, heet Currying, naar de logicus Haskell (!) Curry. Je mag die dus nu bij zijn voornaam noemen.\n\naddx :: Int -> (Int -> Int)\naddx x = \\ y -> x + y\n\n\n\naddtwo = addx 2\n\n\n\naddtwo 3\n\n\n\naddx 2 3\n\n\n\nDeze Currying kunnen we toepassen op alle functies en operatoren met twee of meer parameters, zoals ook bijvoorbeeld de normale reken-operatoren:\n\nsucc = (+) 1 \n\n\n\nsucc 4\n\n\n\nWe kunnen dit ook gebruiken om gespecialiseerde lijst-functies te maken, op basis van algemene lijstfuncties zoals map of foldl.\n\nsum = foldl (+) 0 \n\n\n\nsum [1..10]\n\n\n\n","type":"content","url":"/nb4#functie-als-resultaat","position":9},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functies in datastructuren"},"type":"lvl2","url":"/nb4#functies-in-datastructuren","position":10},{"hierarchy":{"lvl1":"Functies als waarden","lvl2":"Functies in datastructuren"},"content":"\n\nlijst met functies.","type":"content","url":"/nb4#functies-in-datastructuren","position":11},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes"},"type":"lvl1","url":"/nb5","position":0},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes"},"content":"Begrippen\n\ntype-synoniem (alternatieve naam)\n\ndata-type definitie: opsomming van alternatieve waarden\n\nalternatieven: constructors\n\nalternatieven met attributen\n\n","type":"content","url":"/nb5","position":1},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl2":"Alternatieve waarden"},"type":"lvl2","url":"/nb5#alternatieve-waarden","position":2},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl2":"Alternatieve waarden"},"content":"\n\nDe datatypes die we tot nu toe gezien hebben, zowel de elementaire types zoals getallen, als de samengestelde types lijsten en tupels, zijn voorgedefinieerd. Maar, in Haskell kunnen we ook zelf datatypes definiëren.\n\nDe eenvoudigste vorm van een datatype-definitie geeft een opsomming van de namen van de verschillende waarden. Deze waarde-namen heten ook wel constructors - waarom, zal straks duidelijker worden.\nDeze alternatieven kunnen ook van extra waarden (attributen) voorzien zijn, zoals we verderop zullen zien.\n\nDe namen van types en de namen van constructors beginnen in Haskell met een hoofdletter.\n\n","type":"content","url":"/nb5#alternatieve-waarden","position":3},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: kleuren","lvl2":"Alternatieve waarden"},"type":"lvl3","url":"/nb5#voorbeeld-kleuren","position":4},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: kleuren","lvl2":"Alternatieve waarden"},"content":"\n\ndata Color = Red | Orange | Yellow | Green | Blue | Indigo | Violet deriving (Show)\n\n\n\nDe namen van de alternatieven beginnen altijd met een hoofdletter. Zo’n naam heet een constructor, omdat je daarmee een waarde van het betreffende data-type maakt.\n\nDe toevoeging deriving (Show) betekent dat de show-functie voor deze waarden automatisch gedefinieerd wordt; deze laat de waarde zien zoals je deze in een Haskell-programma noteert. Deze show-functie wordt impliciet gebruikt om het resultaat van een cel te tonen.\n\nWe kunnen een kleur-waarde toekennen aan een naam, bijvoorbeeld:\n\nmyColor = Yellow\n\n\n\nshow myColor\n\n\n\nmyColor\n\n\n\nWe kunnen functies definiëren om met deze waarden te “rekenen”. Eigenlijk moeten we alle vormen van rekenen met deze waarden nu zelf definiëren. De functies die we zo definiëren moeten voor elke Color-waarde een resultaat definiëren. We kunnen dat in Haskell doen door een definitie per Color-alternatief te geven:\n\nnextColor :: Color -> Color\nnextColor Red = Orange\nnextColor Orange = Yellow\nnextColor Yellow = Green\nnextColor Green = Blue\nnextColor Indigo = Violet\nnextColor Violet = Violet\n\n\n\nDe structuur van deze functie volgt de structuur van het datatype van de parameter.\n\nnextColor (nextColor myColor)\n\n\n\nWe hebben hier de functie nextColor gedefinieerd door een definitie voor elke mogelijke vorm van Color. Deze constructie heet ook wel pattern matching.\n\nEen alternatief is om een “case analysis” binnen de functie-definitie uit te voeren, zoals in dit voorbeeld:nextColor :: Color -> Color\nnextColor c = \n    case c of\n    Red -> Orange\n    Orange -> Yellow \n    Yellow -> Green\n    Green -> Blue\n    Indigo -> Violet\n    Violet -> Violet\n\n","type":"content","url":"/nb5#voorbeeld-kleuren","position":5},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Bool als data-type","lvl2":"Alternatieve waarden"},"type":"lvl3","url":"/nb5#bool-als-data-type","position":6},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Bool als data-type","lvl2":"Alternatieve waarden"},"content":"Een aantal types zijn voorgedefinieerd in de Haskell “standard prelude”: de standaard-library van Haskell. Het type Bool is daarin bijvoorbeeld gedefinieerd als:data  Bool  =  False | True\n\n","type":"content","url":"/nb5#bool-als-data-type","position":7},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl2":"Alternatieven met attributen"},"type":"lvl2","url":"/nb5#alternatieven-met-attributen","position":8},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl2":"Alternatieven met attributen"},"content":"\n\n","type":"content","url":"/nb5#alternatieven-met-attributen","position":9},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: vormen","lvl2":"Alternatieven met attributen"},"type":"lvl3","url":"/nb5#voorbeeld-vormen","position":10},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: vormen","lvl2":"Alternatieven met attributen"},"content":"\n\nIn het eenvoudige data-type Color spreken de waarden voor zich. Maar bij complexere types kunnen de alternatieven attributen hebben.\n\nEen voorbeeld hiervan is het type Shape (voor een 2-dimensionale geometrische vorm). We onderscheiden (in eerste instantie) cirkels en rechthoeken:\n\neen cirkel heeft een middelpunt (punt) en de straal (Float)\n\neen rechthoek een positie (punt, voor de linker-bovenhoek), een breedte en een hoogte (Floats)\n\neen punt is een 2-tupel van Floats: x- en y-coördinaten.\n\nAls afkorting voeren we het type Point in: een tupel 2 getallen: de x- en y-coördinaat van het punt.\n\ntype Point = (Float, Float)\n\n\n\nDit is een voorbeeld van een type-synoniem: overal waar de naam Point gebruikt wordt, kun je ook (Float, Float) schrijven of lezen.\n\nWe onderscheiden twee vormen: een cirkel, met middelpunt en straal; en een rechthoek, met positie, breedte en hoogte.\n\ndata Shape = Circle Point Float | Rect Point Float Float\n\n\n\nUitzoeken (Hebben we geen andere manier om deze eigenschappen te benoemen en te documenteren?)\n\nUitzoeken: attributen zoals lijndikte, lijnkleur en vulkeur zijn eigenlijk gemeenschappelijk voor alle vormen. Hoe kun je dat het best uitdrukken in Haskell? Een vorm van “overerving”?\n\nLater zullen we toevoegen als vormen:\n\nlijnstuk (met 2 coördinaten: begin- en eindpunt)\n\npad (een lijst van coördinaten; reeks aaneengesloten lijnstukken)\n\ntekst\n\nWe kunnen nu een functie definiëren voor het uitrekenen van de oppervlakte van een (gesloten) figuur. We moeten in die functie de verschillende soorten vormen onderscheiden. In Haskell kan dat door de functie voor elk alternatief afzonderlijk te definiëren:\n\narea :: Shape -> Float\narea (Circle centre radius) = pi * radius * radius\narea (Rect position width height) = width * height\n\n\n\nWe demonstreren dit met twee voorbeeld-vormen:\n\nshape1 = Circle (50, 50) 20\nshape2 = Rect (20, 30) 100 20\n\n\n\narea shape1\n\n\n\narea shape2\n\n\n\nWe kunnen nog meer functies definiëren voor deze vormen\n\ntranslate :: Point -> Shape -> Shape\n\nscale :: Float -> Shape -> Shape\n\ntosvg :: Shape -> String\n\nAls voorbeeld werken we deze laatste functie uit: tosvg, om de SVG-string voor deze vorm te bepalen. Deze kunnen we dan kopiëren in een SVG-figuur, om deze te tonen. (Zie het svg-display notebook.)\n\nDe attributen van een SVG-element hebben allemaal dezelfde structuur: name=\"value\". Hier worden dezelfde dubbele quote-tekens gebruikt als voor Haskell-strings Dat betekent dat we deze niet zomaar in een string kunnen opnemen: we hebben een escape-notatie nodig. De volgende functie maakt deze structuur aan:\n\nattr :: String -> Float -> String\nattr name value = name ++ \"=\\\"\" ++ (show value) ++ \"\\\" \"\n\n\n\nde functie show 2.3 zet het getal om in een string, hier \"2.3\"\n\nattr \"cx\" 12.34\n\n\n\ntosvg :: Shape -> String\ntosvg (Circle (mx, my) r) = \"<circle \" ++ (attr \"cx\" mx) ++ (attr \"cy\" my) ++ (attr \"r\" r) ++ \" /> \\n\"\ntosvg (Rect (mx, my) w h) = \"<rect \" ++ (attr \"x\" mx) ++ (attr \"y\" my) ++ (attr \"width\" w) ++ (attr \"height\" h) ++ \" />\"\n\n\n\ntosvg shape1\n\n\n\nOm dit te kunnen gebruiken in een SVG-figuur, moeten we deze string-waarde in de uitvoer-vorm hebben, in plaats van in de Haskell-notatie; met andere woorden, zonder de quote-tekens, en met de escape-tekens zooals '\\n' en '\\\"' verwerkt. Hiervoor gebruiken we de functie putStr:\n\nputStr (tosvg shape1)\n\n\n\nputStr (tosvg shape2)\n\n\n\nDit resultaat kopiëren we naar de lege regel in de cel met svgimage=..., in het svg-display notebook. (Zie de handleiding daar.)\nVoor een figuur met shape1 en shape2 geeft dit:\n\n\n\nOpdrachten\n\ntoevoegen van andere (SVG) vormen, bijvoorbeeld ellipse en line.\n\nje moet dan per vorm het alternatief toevoegen aan het type; en de bijbehorende functies uitbreiden.\n\ntoevoegen van extra attributen aan de SVG-vormen, bijvoorbeeld de vul-kleur\n\n","type":"content","url":"/nb5#voorbeeld-vormen","position":11},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: expressies","lvl2":"Alternatieven met attributen"},"type":"lvl3","url":"/nb5#voorbeeld-expressies","position":12},{"hierarchy":{"lvl1":"Zelf-gedefinieerde datatypes","lvl3":"Voorbeeld: expressies","lvl2":"Alternatieven met attributen"},"content":"\n\nAls tweede voorbeeld van zelf-gedefineerde datatypes behandelen we expressies. We willen expressies als data kunnen opbouwen. We maken hier een eerste begin, en zullen zien dat deze vorm nogal beperkt is. Voor algemene expressies hebben we recursie nodig: dat komt in het volgende hoofdstuk aan bod.\n\nWe willen een expressie kunnen beschrijven in de vorm van een datatype. We kunnen deze expressies als waarde gebruiken, en op verschillende manieren manipuleren.\nAls operatoren gebruiken we in eerste instantie alleen optelling (Plus) en vermenigvuldiging (Times), en een elementaire waarde (Num).\nAls operanden voor de operatoren gebruiken we voorlopig getallen: dat geeft al direct de beperking aan. In het volgende hoofdstuk zullen we dat generaliseren.\n\ndata Expr = Num Float | Plus Float Float | Times Float Float deriving (Show)\n\n\n\nEnkele voorbeelden van waarden van dit datatype:\n\npi = Num 3.1415629\ntwopi = Times 2.0 3.1415629\nexpr3 = Plus 2 21\n\n\n\npi\n\n\n\ntwopi\n\n\n\nexpr3\n\n\n\nWe kunnen nu een functie eval maken, voor het evalueren van een expressie:\n\neval :: Expr -> Float\neval (Num val) = val\neval (Plus l r) = l + r\neval (Times l r) = l * r\n\n\n\neval pi\n\n\n\nWe kunnen de operatoren ook in postfix afdrukken. Daarbij krijgen we eerst de operanden, en daarna de operator. (Sommige rekenmachines werken met die notatie. Een voordeel is dat je dan geen haakjes nodig hebt.)\n\npostfix :: Expr -> String\npostfix (Num val) = show val\npostfix (Plus l r) = (show l) ++ \" \" ++ (show r) ++ \" \" ++ \"+\"\npostfix (Times l r) = (show l) ++ \" \" ++ (show r) ++ \" \" ++ \"+\"\n\n\n\npostfix expr3\n\n\n\nRecursie als volgende stap. We hebben recursie nodig: eigenlijk willen we kunnen schrijven:twopi = Times 2 pi\n\nDaarvoor moet de waarde van een operand (attribuut) van Times een Num Float waarde kunnen zijn, of in het algemeen: een Expr waarde. Daar gaan we in het volgende hoofdstuk mee aan de slag.","type":"content","url":"/nb5#voorbeeld-expressies","position":13},{"hierarchy":{"lvl1":"Recursieve datatypes"},"type":"lvl1","url":"/nb8","position":0},{"hierarchy":{"lvl1":"Recursieve datatypes"},"content":"\n\n","type":"content","url":"/nb8","position":1},{"hierarchy":{"lvl1":"Recursieve datatypes","lvl2":"Voorbeeld: expressies"},"type":"lvl2","url":"/nb8#voorbeeld-expressies","position":2},{"hierarchy":{"lvl1":"Recursieve datatypes","lvl2":"Voorbeeld: expressies"},"content":"\n\nWe hebben in het vorige hoofdstuk gezien dat we voor algemene expressies recursie nodig hebben: een argument van een operator-knoop kan weer een expressie zijn.\n\nDit kunnen we weergeven in de volgende definitie: (later voegen we meer operatoren toe)\n\ndata Expr = Add Expr Expr\n          | Mul Expr Expr\n          | Val Float\n\n\n\nMerk op:\n\nin de definitie van Expr komt Expr weer voor in de definiërende termen in de rechterkant: dit is recursie. (Letterlijk: komt weer voor)\n\nhet alternatief Val Float is niet recursief. In een recursieve (data)definitie moet tenminste één alternatief niet-recursief zijn.\n\nMet behulp van deze definitie kunnen we nu waarden construeren:\n\nexpr1 = Add (Val 1) (Val 2.5)\n\n\n\nexpr2 = Add (Mul (Val 2) (Val 7.5)) (Val 3)\n\n\n\nWe kunnen nu functies definiëren op Expr-waarden. Een dergelijke functie moet een alternatieve definitie hebben voor elk alternatief in de data-definitie. Anders gezegd: een functie die werkt op Expr-waarden volgt de structuur van het Expr data-type.\n\nAls voorbeeld geven we een functie om een Expr-waarde uit te rekenen. Merk op dat we haakjes om de parameters van eval moeten schrijven, omdat eval Add a b gelezen wordt als (eval Add) a b\n\neval :: Expr -> Float\neval (Add a b) = (eval a) + (eval b)\neval (Mul a b) = (eval a) * (eval b)\neval (Val a) = a\n\n\n\neval expr1\n\n\n\neval expr2\n\n\n\nWe schrijven hier de uitwerking van deze laatste uitdrukking uit:\n\n  eval expr2\n=   {def. expr2}\n  eval (Add (Mul (Val 2) (Val 7.5)) (Val 3)\n=   {def. eval, voor Mul-alternatief}\n  (eval (Mul (Val 2) (Val 7.5)) + (eval (Val 3))\n=   {def. eval, voor Add-alternatief}\n  ((eval (Val 2)) * (eval (Val 7.5))) + (eval (Val 3))\n=   {def. eval, voor alle Val-alternatieven}\n  ((2) * (7.5)) + (3)\n=   {rekenen}\n  (15.0) + (3)\n=   {rekenen}\n  18.0\n\n\nVoorbeeld. Met behulp van de functie postfix zetten we een Expr-waarde om in een string, in postfix-formaat: eerst de argumenten, dan de operator.\n\npostfix :: Expr -> String\npostfix (Add a b) = (postfix a) ++ (postfix b) ++ \" + \"\npostfix (Mul a b) = (postfix a) ++ (postfix b) ++ \" * \"\npostfix (Val a) = show a ++ \" \"\n\n\n\n\npostfix expr2\n\n\n\nOpdracht Maak een functie om een Expr-waarde om te zetten in prefix-formaat: eerst de operator, dan de argumenten.\n\nVariant: probeer de string in Haskell-formaat te maken, waarbij je de operatoren als functies beschouwt. (Gebruik de Haskell-notatie: (+) 3 4 - met de operatoren tussen haakjes).\n\n","type":"content","url":"/nb8#voorbeeld-expressies","position":3},{"hierarchy":{"lvl1":"Recursieve datatypes","lvl2":"Voorbeeld: vormen"},"type":"lvl2","url":"/nb8#voorbeeld-vormen","position":4},{"hierarchy":{"lvl1":"Recursieve datatypes","lvl2":"Voorbeeld: vormen"},"content":"\n\n\n\nWe voegen aan de grafische figuren groepering toe, waarbij we een lijst van grafische elementen samenvoegen tot één element. Bovendien voegen we tranformaties toe aan deze groepen.\n\nGroepering is in tekenprogramma’s een gebruikelijke operatie. De elementen in een groep kun je dan tegelijk verplaatsen, en bijvoorbeeld ook tegelijk kopiëren. Als je de afzonderlijke elementen wilt bewerken, kun je deze groepering (tijdelijk) opheffen.\n\nIn SVG kun je in een groep ook de vormgeving van de elementen in de groep bepalen, zoals de vulkeur of de pendikte.\n\n(Wij voegen hier een positie toe aan een groep: dat komt overeen met een translate van de elementen in de groep.)\n\ntype Point = (Float, Float)\n\n\n\ndata Shape = Circle Point Float\n           | Rect Point Float Float\n           | Text Point String\n           | Line Point Point\n           | Grp Point [Shape]\n             deriving (Show)\n\n\n\nshape1 = Circle (10, 10) 20\nshape2 = Rect (20, 10) 100 20\n\n\n\nshape3 = Line (10, 10) (100, 100)\n\n\n\nattr :: String -> Float -> String\nattr name value = name ++ \"=\\\"\" ++ (show value) ++ \"\\\" \"\n\n\n\ntosvg :: Shape -> String\ntosvg (Circle (mx, my) r) = \"<circle \" ++ (attr \"cx\" mx) ++ (attr \"cy\" my) ++ (attr \"r\" r) ++ \" /> \\n\"\ntosvg (Rect (mx, my) w h) = \"<rect \" ++ (attr \"x\" mx) ++ (attr \"y\" my) ++ (attr \"width\" w) ++ (attr \"height\" h) ++ \"/> \\n\"\ntosvg (Text (mx, my) s) = \"<text x=\" ++ (attr \"x\" mx) ++ (attr \"y\" my) ++ \">\" ++ s ++ \"</text> \\n\"\ntosvg (Line (ax, ay) (bx, by)) = \"<line \" ++ (attr \"x1\" ax) ++ (attr \"y1\" ay) ++ (attr \"x2\" bx) ++ (attr \"y2\" by) ++ \"/> \\n\"\ntosvg (Grp (mx, my) lst) = \"<g transform=\\\"translate(\" ++ (show mx) ++ \" \" ++ (show my) ++ \")\\\" > \\n\" ++ elems ++ \"</g>\\n\"\n                           where svg_lst = map tosvg lst\n                                 elems = foldr (++) \"\" svg_lst\n\n\n\nputStr (tosvg shape1)\n\n\n\nshape4 = Grp (10, 20) [shape1, Grp (50, 50) [shape1, shape2, shape3], shape2]\n\n\n\nshape4\n\n\n\nputStr (tosvg shape4)\n\n\n\nDit geeft de volgende figuur:\n\n\n\nOpdracht\n\nmaak een figuur die een huisje of een poppetje voorstelt (en geef deze een naam)\n\nmaak een figuur die bovenstaande 3-maal naast elkaar herhaalt.\n\n","type":"content","url":"/nb8#voorbeeld-vormen","position":5},{"hierarchy":{"lvl1":"Haskell-notatie"},"type":"lvl1","url":"/notatie","position":0},{"hierarchy":{"lvl1":"Haskell-notatie"},"content":"Commentaar: tekst na -- tot aan het einde van de regel is commentaar.\n\n3 + 4 -- een eenvoudige som\n\n\n\nDefinities: een definitie is van de vorm:  naam = waarde\n\na = 3 + 4\n\n\n\nsqr = \\x -> x * x\n\n\n\nFunctie-definitie. Voor functies gebruiken we vaak een verkorte notatie: sqr x = x * x\n\nsqr 3\n\n\n\nLambda-expressies (anonieme functies)\nEen lambda-expressie heeft de vorm:\n\n\\  parameters   -> expressie\n\nVoorbeeld: \\x y -> x * y\n\ndouble = \\x -> x + x\n\n\n\ndouble 1\n\n\n\nFunctie-applicatie (functie-aanroep, functie-toepassing)\nDe naam van de functie (of de functie-expressie) gevolgd door de argumenten.\n\nf-name arg1 arg2\n\nVoorbeeld: f 3 4\n\nHaskell gebruikt geen haakjes om functie-applicatie aan te geven, en ook geen komma’s bij meerdere parameters. In andere talen zou je dit schrijven als: f(3, 4).\n\nFunctie-compositie\nEen functie kan ook het resultaat zijn van een berekening, bijvoorbeeld functie-compositie. Je krijgt dan bijvoorbeeld: (f . g) 3 4 - hierin is . de compositie-operator. (Functie-applicatie bindt sterker dan functie-compositie, daarom zijn hier haakjes nodig.)\n\nMet andere woorden: (f . g) x is gelijk aan: f(g(x)) (Dit heet ook wel “backward composition”, omdat de input helemaal rechts staat, en de output links.\n\n(sqr . double) 1\n\n\n\nIn sommige programmeertalen heb je “forward function composition”. Je geeft dat eerst het argument, en krijgt bijv.: x |> g |> f voor f(g(x)).\n\nOperator als functie. In Haskell zijn de operatoren zoals + en * ook gewoon functies (van twee parameters). Alleen de syntax is anders: deze functies worden tussen de argumenten geplaatst, in plaats van ervoor. Maar je kunt deze functies ook in de “normale” syntax gebruiken, door deze tussen haakjes te plaatsen.\n\n\n\n\n\n(+) 3 4\n\n\n\n\n\n\n\nDeze notatie voor een operator kan ook handig zijn als je de operator als functie-waarde wilt gebruiken, bijvoorbeeld om deze als argument aan een andere functie mee te geven:\n\nfoldl (+) 0 [1..10]\n\n\n\n\n\n\n\n\n\n\n\nInspringen heeft (of niet) heeft betekenis (als in Python)\n\nGewoonlijk gebruiken we de layout-gevoelige versie van Haskell, te vergelijken met Python. Er is een alternatieve notatie, met o.a. accolades en ;. Accolades voor groepering, bijv. van definities; en ; voor het scheiden van de definities.\n\nGeen accolade na where, let, of, do: “offside rule” wordt gebruikt. (Eigenlijk worden op basis van de layout dan accolades en puntkomma’s toegevoegd. zie: \n\nhttps://​www​.haskell​.org​/onlinereport​/haskell2010​/haskellch2​.html​#x7​-210002.7\n\n; kun je ook gebruiken zonder accolades, bijv. bij meerdere definities op 1 regel.\n\nNamen van waarden en van (gewone) functies beginnen met een kleine letter\n\nNamen van types en van constructors beginnen met een hoofdletter\n\nuitvoer van strings\n\nAls je een string-waarde laat zien in een notebook-cel, dan krijg je die in de Haskell-notatie, inclusief de quote-tekens:\n\n\"Hello World\"\n\n\n\nAls je deze string-waarde wilt tonen als uitvoer, zonder de quotes, dan kun je putStr gebruiken:\n\nputStr \"Hello World\"\n\n\n\nNog een voorbeeld, waarin de string een speciaal teken bevat: '\\n', het newline teken, om de overgang naar een volgende regel aan te geven:\n\n\"Hello \\nWorld\"\n\n\n\nEn nu de uitvoer waarin de speciale tekens verwerkt worden:\n\nputStr \"Hello \\nWorld\"\n\n","type":"content","url":"/notatie","position":1},{"hierarchy":{"lvl1":"Over deze module"},"type":"lvl1","url":"/over-deze-module","position":0},{"hierarchy":{"lvl1":"Over deze module"},"content":"De aanpak van het thema functioneel programmeren is wat anders dan gebruikelijk, met als bedoeling de essentiële begrippen op een logische en geleidelijke manier in te voeren.\n\nEén van de uitgangspunten is “gebruik voor definitie”: voor het gebruik heb je voldoende aan een specificatie, die soms wat informeel kan zijn. Bij de implementatie komen dan alle formele details aan bod, maar op dat moment is de noodzaak van die details vaak wel duidelijk.\n\nFunctioneel programmeren gaat voor een belangrijk deel over abstractie. Maar het is belangrijk om zo concreet mogelijk te beginnen, en de abstractie daarna in te voeren als een volgende, logische stap.\n\nFuncties. Het eerste onderdeel betreft het functiebegrip: een functie als uitgestelde berekening. Er zijn twee redenen om die berekening uit te stellen:\n\n(a) je kent de invoer (argumenten) van de functie nog niet;\n\n(b) je hebt het resultaat van de functie nog niet nodig.\n\nAd (a): als je een functie toepast op één of meerdere argument-waarden, kun je de berekening van de functie (uit de functie-definitie) uitvoeren.\n\nAd (b): je hoeft de functie niet uit te voeren, ook als de invoer (argumenten) wel beschikbaar zijn in een functie-toepassing; dit kun je uitstellen totdat het resultaat van deze functie-toepassing nodig is. Dit lazy evaluation principe wordt in sommige functionele programmeertalen, zoals ook Haskell, gebruikt. In onze voorbeelden zullen we echter vrijwel altijd een stricte evaluatie gebruiken: we rekenen een functie-toepassing uit zodra de argumenten beschikbaar zijn.\n\nHet belangrijkste van dit hoofdstuk is het onderscheid tussen een functie, als rekenvoorschrift of uitgestelde berekening, en de toepassing (of “aanroep”) van die functie, waarbij die berekening uitgevoerd wordt. (wanneer de omvattende berekening uitgevoerd wordt) (Ook: denken in termen van het effect van de functie, in plaats van de implementatie).\n\nWe introduceren een eenvoudig rekenmodel, waarbij een expressie via het invullen van waarden stapsgewijs uitgerekend wordt tot een enkele waarde.\n\nOok: functie als abstractie, kunnen werken met een functie op basis van de specificatie van die functie, zonder kennis van de definitie (implementatie).\n\nBelangrijke begrippen hierbij zijn: waarden, namen (gekoppeld aan waarden), functie-specificatie (interface): parameters, resultaat; functie-toepassing (“aanroep”), op bepaalde argument-waarden; functie-definitie. (functie als afbeelding?)\n\nHogere-orde functies.\n\nBelangrijke begrippen: lambda-expressie (anonieme functies). Functie als parameter. Functie als resultaat. map, fold (of reduce), filter; lijst-waarden; partiële evaluatie, Currying.\n\nZelf-gedefinieerde data-types.\n\nStructuur het een functie volgt de structuur van het data-type (van het argument).\n\nRecursieve data-types en recursieve functies.\n\nStructuur van de (recursieve) functie volgt de structuur van het data-type.\n\nEen recursieve definitie, van een data-type of van een functie, heeft naast de recursieve alternatieven tenminste één niet-recursief alternatief, om de “recursie te eindigen”.\n\nLijst als recursief data-type.\n\nHaskell-lijst als recursief data-type; geparametriseerde (generieke) data-types.\ndefinitie (implementatie) van (generieke) functies als map, fold en filter.\n\nBomen\n\nBinaire bomen, zoekbomen, afdrukken van bomen; flatten, opbouwen van bomen; (B-trees?)","type":"content","url":"/over-deze-module","position":1},{"hierarchy":{"lvl1":"Overzicht"},"type":"lvl1","url":"/overzicht","position":0},{"hierarchy":{"lvl1":"Overzicht"},"content":"Hoofdstuk\n\nonderdelen\n\n\n\n1\n\nwaarden, expressies en namen\n\n\n\n1\n\nfuncties: definitie en toepassing\n\n\n\n2\n\ntypering, samengestelde waarden, lijsten\n\n\n\n2\n\ntypering van functies\n\n\n\n3\n\nfuncties als waarden; map, fold\n\n\n\n4\n\nzelf-gedefinieerde data-types; functies daarvoor\n\n\n\n4\n\ngeparametriseerde types; generieke functies\n\n\n\n5\n\nrecursieve data-types; recursieve functies daarvoor\n\n\n\n6\n\nfuncties op lijsten; map, fold\n\n\n\n7\n\nbomen en de toepassingen daarvan\n\n\n\n7\n\nzoeken en sorteren\n\n\n\n8\n\ngrotere voorbeelden\n\n","type":"content","url":"/overzicht","position":1},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Waarden, expressies en namen"},"type":"lvl2","url":"/overzicht#waarden-expressies-en-namen","position":2},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Waarden, expressies en namen"},"content":"begrippen: waarde, expressie, operator, operator-prioriteit (precedentie?), naam-definitie, naam-gebruik, rekenen/herschrijven (berekening)\n\neen expressie beschrijft een berekening. Wanneer deze berekening uitgevoerd wordt, is het resultaat van deze berekening een waarde (getal, string, enz.)\n\neen expressie bestaat uit waarden (voorlopig alleen gehele getallen), operatoren (en functies? bijv. div, mod?, abs, neg?, succ, pred)\n\nfunctie-toepassing heeft in Haskell de vorm: f 3\n\nde naam van de functie met daarachter het argument waarop de functie toegepast wordt.\n\nin plaats van f(3) (zoals gebruikelijk in veel andere programmeertalen, of in de wiskunde)\n\nfunctie-toepassing bindt sterker dan operatoren als +, *, enz.\n\nvoorbeelden: enkele uitgewerkte berekeningen\n\nopdrachten: uitwerken van enkele berekeningen","type":"content","url":"/overzicht#waarden-expressies-en-namen","position":3},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Functies"},"type":"lvl2","url":"/overzicht#functies","position":4},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Functies"},"content":"begrippen: functie-definitie, functie-naam, parameters, functie-toepassing (applicatie, aanroep), argumenten\n\neen functie kun je zien als de abstractie van een berekening: de interface beschrijft het effect(?), de expressie (body) de implementatie: de berekening voor het bereiken van dat effect.\n\nin het geval van functies kun je het effect beschrijven als een relatie tussen de parameters en het resultaat.\n\neen voorbeeld is ggd x y - het effect is: het grootste getal dat zowel een deler is van x als van y; dit zegt nog niets over de manier waarop je dit kunt berekenen. (Dit is overigens een klassiek informatica-voorbeeld.)\n\neen ander voorbeeld: sort xs - het effect is:\n\neen functie kun je (ook) zien als een uitgestelde berekening, vanwege het ontbreken van de waarden van de parameters. Zodra deze bekend zijn, bij functie-applicatie, kun je de berekening uitvoeren.\n\nvoorbeelden: sqr (definitie en toepassing), succ (en functies met twee parameters?)\n\nopdrachten: uitwerken van enkele berekeningen; def. van double","type":"content","url":"/overzicht#functies","position":5},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Types en waarden"},"type":"lvl2","url":"/overzicht#types-en-waarden","position":6},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Types en waarden"},"content":"begrippen:\n\nvoorbeelden:","type":"content","url":"/overzicht#types-en-waarden","position":7},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Elementaire types","lvl2":"Types en waarden"},"type":"lvl3","url":"/overzicht#elementaire-types","position":8},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Elementaire types","lvl2":"Types en waarden"},"content":"concepten: typering van waarden; typering van functies\n\nGetallen, tekens, boolean\n\nvoorbeelden:","type":"content","url":"/overzicht#elementaire-types","position":9},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Samengestelde types","lvl2":"Types en waarden"},"type":"lvl3","url":"/overzicht#samengestelde-types","position":10},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Samengestelde types","lvl2":"Types en waarden"},"content":"Strings, lijsten; tupels","type":"content","url":"/overzicht#samengestelde-types","position":11},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Typering van functies","lvl2":"Types en waarden"},"type":"lvl3","url":"/overzicht#typering-van-functies","position":12},{"hierarchy":{"lvl1":"Overzicht","lvl3":"Typering van functies","lvl2":"Types en waarden"},"content":"(In het bijzonder ook: functies van meerdere parameters.)","type":"content","url":"/overzicht#typering-van-functies","position":13},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Functies als waarden"},"type":"lvl2","url":"/overzicht#functies-als-waarden","position":14},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Functies als waarden"},"content":"anonieme functie-waarden: lambda-expressies\n\n(overeenkomst tussen lambda-expressie en regel voor functie-applicatie: let)\n\nmap\n\nfoldl, foldr, (reduce)\n\nfilter\n\nzip (tupels en lijsten)\n\nfuncties met meerdere parameters; partiële parametrisatie (Currying)\n\n(De uitdaging van het gebruik van map, foldl, filter enz. is om te denken in complete lijsten, niet in de afzonderlijke elementen.)\n\n(Bij dit hoofdstuk moeten we een redelijk groot aantal oefeningen hebben, om leerlingen vertrouwd te maken met de verschillende begrippen en de manier waarop je die gebruikt. Een aantal kleine voorbeelden moet met de hand uitgewerkt worden, voor een beter begrip.)","type":"content","url":"/overzicht#functies-als-waarden","position":15},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Zelf-gedefinieerde data-types"},"type":"lvl2","url":"/overzicht#zelf-gedefinieerde-data-types","position":16},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Zelf-gedefinieerde data-types"},"content":"constructors (met parameters)\n\nfunctie-definities met pattern matching (eigenlijk: “de-constructie”)\n\nvoorbeelden:\n\ngrafische (geometrische vormen) - cirkel, rechthoek, driehoek, trapezium, ster?\n\nbepalen van oppervlakte\n\n\n\nexpressie - operator met operanden, (bijv. +, -. *. mod, div); functie met argumenten?\n(De voorbeelden in dit hoofdstuk bereiden voor op de “logische” uitbreiding naar groepering, en daarmee naar recursie.)\n\n(Eigenlijk zou ik de vormen zo willen definiëren dat je deze ook kunt tekenen; dan moeten we ook met coördinaten werken, bijvoorbeeld in de vorm van tupels.)","type":"content","url":"/overzicht#zelf-gedefinieerde-data-types","position":17},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Recursie: data-types en functies"},"type":"lvl2","url":"/overzicht#recursie-data-types-en-functies","position":18},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Recursie: data-types en functies"},"content":"recursieve data-types\n\ngrafische vormen - met groepering\n\nexpressies - met sub-expressies\n\nrecursieve functies voor recursieve data\n\ngrafische vormen, bijv. berekenen van oppervlak (of: omzetten in SVG)\n\nexpressies, bijv. evaluatie\n\nbinaire bomen\n\ngenerieke bomen (met willekeurig aantal kinderen)\n\nbomen in de informatica\n\nrecursieve structuren (o.a file system; en eerdere genoemde voorbeelden)\n\nzoekbomen\n\nlijsten - en functies op lijsten (sum, max, lst_sqr)","type":"content","url":"/overzicht#recursie-data-types-en-functies","position":19},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Generieke functies (map enz.)"},"type":"lvl2","url":"/overzicht#generieke-functies-map-enz","position":20},{"hierarchy":{"lvl1":"Overzicht","lvl2":"Generieke functies (map enz.)"},"content":"definities van map, foldl (en foldr)\n\n(en nog enkele andere functies)","type":"content","url":"/overzicht#generieke-functies-map-enz","position":21},{"hierarchy":{"lvl1":"Module Functioneel Programmeren"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Module Functioneel Programmeren"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"SVG display"},"type":"lvl1","url":"/svg-display","position":0},{"hierarchy":{"lvl1":"SVG display"},"content":"Dit is een Python-notebook, bedoeld om SVG-figuren weer te geven, met behulp van de HTML-display mogelijkheden.\n\nfrom IPython.display import display, HTML\n\n\n\nEen voorbeeld van het tonen van HTML:\n\ndisplay(HTML('<h3>Hello, world!</h3>'))\n\n\n\nEen voorbeeld van een svg-figuur\n\nmysvg = '''\n<svg width=\"300\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n<g transform=\"translate(10.0 10.0)\" stroke=\"black\" fill=\"white\"> \n<circle cx=\"50.0\" cy=\"50.0\" r=\"20.0\"  /> \n<rect x=\"50.0\" y=\"50.0\" width=\"100.0\" height=\"20.0\" />\n</g>'''\n\n\n\ndisplay(HTML(mysvg))\n\n\n\nHoe gebruik je dit?\n\nkopieer je SVG-code op de plek van de lege regel hieronder, tussen de regels met de '''-quotes.\n\nvoer de cellen hieronder uit, tot en met de cel met display(HTML(svgframe))\n\n\n\nDe code hieronder kan gebruikt worden om SVG-code te tonen.\nDe invoer kan gegeven worden in de cell met svgimage.\nDoor de volgende cellen uit te voeren wordt de figuur verder opgebouwd en getoond.\n\nsvgimage = '''\n\n'''\n\n\n\nEen SVG-figuur heeft een context nodig, deze kun je eventueel aanpassen, bijvoorbeeld om een andere vulkleur te krijgen, of een andere lijn-kleur of -dikte.\n\nsvgframe = '<svg width=\"400\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">' + \\\n           '<g fill=\"white\" stroke=\"black\" stroke-width=\"1\">' + \\\n             svgimage + \\\n           '</g>' + \\\n           '</svg>'\n\n\n\ndisplay(HTML(svgframe))\n\n\n\nHieronder is ruimte voor nog enkele zelf-te definiëren SVG-figuren:\n\nsvgimage1 = ‘’’\n\n‘’’\n\nsvgframe1 = ‘’\n\ndisplay(HTML(svgframe))\n\n","type":"content","url":"/svg-display","position":1},{"hierarchy":{"lvl1":"SVG display","lvl2":"SVG-bestanden"},"type":"lvl2","url":"/svg-display#svg-bestanden","position":2},{"hierarchy":{"lvl1":"SVG display","lvl2":"SVG-bestanden"},"content":"\n\nJe kunt je SVG-tekst ook kopiëren naar een SVG-bestand, wat je dan vervolgens kunt tonen als een figuur in een notebook.\n\nVoorlopig met je dit kopiëren met de hand doen: het schrijven naar (tekst) bestanden vanuit deze Haskell-kernel levert nog enkele problemen.\n\nSVG als image in Markdown:\n\n\n\nSVG als image in Markdown:","type":"content","url":"/svg-display#svg-bestanden","position":3},{"hierarchy":{"lvl1":"Voor de docent"},"type":"lvl1","url":"/voor-de-docent","position":0},{"hierarchy":{"lvl1":"Voor de docent"},"content":"PRIMM Als didactische aanpak gebruiken we, waar mogelijk, de PRIMM methode: Predict, Read, Investigate, Modify, Make. Leerlingen beginnen met het lezen en begrijpen van bestaande code.\n\nhet is dan belangrijk om goede voorbeelden te kiezen.\n\nGebruik voor implementatie. In het algemeen proberen we voorbeelden van het gebruik te laten zien, voordat we ingaan op de implementatie.\n\nUitwerken met de hand. Om een goed begrip te krijgen van de verschillende constructies, is het belangrijk om een aantal voorbeelden met de hand uit te werken.\n\nKleine stappen, controleren cq. testen. We gebruiken Jupyter Notebook (of -Lab) om programma’s op te kunnen bouwen in kleine stappen, waarbij elke stap getest kan worden met een of twee kleine voorbeelden.\n\nWelke voorbeelden kies je om te testen? Zorg in elk geval dat je de randgevallen apart test, zoals bijvoorbeeld de lege lijst. En daarnaast een of twee “normale” gevallen.","type":"content","url":"/voor-de-docent","position":1},{"hierarchy":{"lvl1":"Voor de docent","lvl2":"Tips voor het gebruik van Jupyter Notebook"},"type":"lvl2","url":"/voor-de-docent#tips-voor-het-gebruik-van-jupyter-notebook","position":2},{"hierarchy":{"lvl1":"Voor de docent","lvl2":"Tips voor het gebruik van Jupyter Notebook"},"content":"gebruik Jupyter Notebook om te experimenteren met de voorbeelden: pas de voorbeeld-data aan, en pas de voorbeeld-functies aan.\n\nde volgorde van de berekening is belangrijk, hiermee bouw je een historie op: na een aantal experimenten kan het zijn dat de actuele inhoud van de cellen niet meer klopt met de opgebouwde berekening-historie (van definities e.d.). Het is handig om regelmatig de kernel opnieuw te starten (bijv. Restart Kernel and Clear... of Restart Kernel and Run up to Selected Cell).\n\n","type":"content","url":"/voor-de-docent#tips-voor-het-gebruik-van-jupyter-notebook","position":3}]}